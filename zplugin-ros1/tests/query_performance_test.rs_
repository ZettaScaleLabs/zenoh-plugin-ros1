//
// Copyright (c) 2022 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//

use zenoh::{prelude::SplitBuffer, queryable::Queryable};
use zenoh_core::SyncResolve;
use zenoh::prelude::r#async::*;
use zenoh_core;

use serial_test::serial;

use async_std;

use std::{
    sync::{
        atomic::{Ordering::{Relaxed, SeqCst}, AtomicU64, AtomicBool},
        Arc
    },
    time
};


async fn probe_loop(session: Arc<Session>, name: String, data: Arc<Vec<u8>>, counter: Arc<AtomicU64>) {
    loop {
        let query = session.get(name.clone())
                                                            .with_value(data.as_ref().clone())
                                                            .res_async().await;
        match query {
            Ok(result) => {
                match result.recv_async().await {
                    Ok(res) => {
                        match(res.sample) {
                            Ok(sample) => {
                                break;
                            }
                            Err(e) => {}
                        }
                    }
                    Err(e) => {}
                }
            }
            Err(e) => {}
        }
    }
}

async fn query_loop(session: Arc<Session>, name: String, data: Arc<Vec<u8>>, counter: Arc<AtomicU64>, works: Arc<AtomicBool>) {
    while works.load(Relaxed) {
        let query = session.get(name.clone())
                                                            .with_value(data.as_ref().clone())
                                                            .res_async().await;
        match query {
            Ok(result) => {
                match result.recv_async().await {
                    Ok(res) => {
                        match(res.sample) {
                            Ok(sample) => {
                                let returned_data = sample.value.payload.contiguous().to_vec();
                                assert!(data.as_ref().eq(&returned_data));
                                counter.fetch_add(1, SeqCst);
                            }
                            Err(e) => {
                                print!("Error: {}", e);
                            }
                        }
                    }
                    Err(e) => {
                        print!("Error: {}", e);
                    }
                }
            }
            Err(e) => {
                print!("Error: {}", e);
            }
        }
    }
}

async fn echo(q: zenoh::queryable::Query) {
    let payload = q.value().unwrap().payload.contiguous().to_vec();
    q.reply(Ok(zenoh::prelude::Sample::new(q.key_expr().clone(), payload))).res_async().await.unwrap();
}

async fn pair_measure_loop(querying_session: Arc<Session>, 
                           data: Arc<Vec<u8>>, 
                           counter: Arc<AtomicU64>, 
                           names: Vec<String>,
                           queryables_per_session: u32,
                           queryables_per_measure: u32) {
    let mut queryables = Vec::new(); 
    let mut loops = Vec::new();
    let mut i=0;
    let works = Arc::new(AtomicBool::new(true));

    let mut queryable_session = zenoh::open(zenoh::config::default()).res_sync()
                                                                                           .unwrap()
                                                                                           .into_arc();

    for name in names {
        i += 1;

        // create new session
        if i % queryables_per_session == 0 {
            queryable_session = zenoh::open(zenoh::config::default())
                .res_sync()
                .unwrap()
                .into_arc();
        }

        // create queryable
        queryables.push(queryable_session.declare_queryable(name.clone())
                                         .callback( |q| { async_std::task::spawn(echo(q));} ).res_async().await.unwrap());

        // recently created queryable may become available later, so we probe it here
        probe_loop(querying_session.clone(), name.clone(), data.clone(), counter.clone()).await;

        // create query loop
        loops.push(async_std::task::spawn(query_loop(querying_session.clone(), name, data.clone(), counter.clone(), works.clone())));

        // each queryables_per_measure we do perform measurement
        if i % queryables_per_measure == 0 {
            // warm up
            async_std::task::sleep(time::Duration::from_millis(100)).await;

            // bench
            counter.store(0, Relaxed);
            async_std::task::sleep(time::Duration::from_secs(1)).await;
            let pps = counter.load(Relaxed);
            print!("{}, {}\n", loops.len(), pps);
        }
    }

    works.store(false, Relaxed);
    futures::future::join_all(loops).await;
}

async fn run_pairs(instances: u32,
                   queryables_per_session: u32,
                   queryables_per_measure: u32) {
    // make session
    let querying_session = zenoh::open(zenoh::config::default())
        .res_sync()
        .unwrap()
        .into_arc();

    // make names
    let mut names = Vec::new(); 
    for i in 0..instances {
        let name = format!("some/key/expr{}", i);
        names.push(name);
    }

    // make counter
    let counter = Arc::new(AtomicU64::new(0));

    // make data
    let array: Vec<u8> = (0..100).collect();
    let data = Arc::new(array);

    pair_measure_loop(querying_session, 
                      data, 
                      counter, 
                      names, 
                      queryables_per_session, 
                      queryables_per_measure).await;
}

fn run_check_zenoh_query(instances: u32,
                         queryables_per_session: u32,
                         queryables_per_measure: u32) {
    async_std::task::block_on(run_pairs(instances,
                                                queryables_per_session,
                                                queryables_per_measure));
}

//#[test]
//#[serial]
fn test_query_perf_session_per_1_queryable() {
    run_check_zenoh_query(100, 1, 10); 
}

//#[test]
//#[serial]
fn test_query_perf_session_per_10_queryables() {
    run_check_zenoh_query(1000, 10, 10);
}

//#[test]
//#[serial]
fn test_query_perf_single_session() {
    run_check_zenoh_query(1000, 3000, 10);
}