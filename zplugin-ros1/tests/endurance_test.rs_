//
// Copyright (c) 2022 ZettaScale Technology
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ZettaScale Zenoh Team, <zenoh@zettascale.tech>
//

use zenoh::{prelude::SplitBuffer, queryable::Queryable};
use zenoh_core::SyncResolve;
use zenoh::prelude::r#async::*;
use zenoh_core;

use async_std;

use std::{
    sync::{
        atomic::{Ordering::Relaxed, AtomicU64},
        Arc
    },
    time
};



async fn pps_loop(counter: Arc<AtomicU64>) {
    loop {
        counter.store(0, Relaxed);
        async_std::task::sleep(time::Duration::from_secs(1)).await;
        let pps = counter.load(Relaxed);
        print!("PPS: {}\n", pps);
        //assert!(pps > 0);
    }
}

async fn query_loop(session: Arc<Session>, name: String, data: Arc<Vec<u8>>, counter: Arc<AtomicU64>) {
    loop {
        let query = session.get(name.clone())
                                                            .with_value(data.as_ref().clone())
                                                            .res_async().await;
        match query {
            Ok(result) => {
                match result.recv_async().await {
                    Ok(res) => {
                        let returned_data = res.sample.unwrap().value.payload.contiguous().to_vec();
                        assert!(data.as_ref().eq(&returned_data));
                        counter.fetch_add(1, Relaxed);
                    }
                    Err(..) => {}
                }
            }
            Err(..) => {}
        }
    }
}

async fn run_querying(instances: u32) {
    // make session
    let session = zenoh::open(zenoh::config::default())
        .res_sync()
        .unwrap()
        .into_arc();
    
    // make names
    let mut names = Vec::new(); 
    for i in 0..instances {
        let name = format!("some/key/expr{}", i);
        names.push(name);
    }

    // make counter
    let counter = Arc::new(AtomicU64::new(0));

    // make data
    let array: Vec<u8> = (0..100).collect();
    let data = Arc::new(array);

    // make loops as tasks
    let mut loops = Vec::new();
    for name in names {
        loops.push(async_std::task::spawn(query_loop(session.clone(), name, data.clone(), counter.clone())));
    }

    // spawn pps task
    async_std::task::spawn(pps_loop(counter));

    // do work
    futures::future::join_all(loops).await;
}


async fn echo(q: zenoh::queryable::Query) {
    let payload = q.value().unwrap().payload.contiguous().to_vec();
    q.reply(Ok(zenoh::prelude::Sample::new(q.key_expr().clone(), payload))).res_async().await.unwrap();
}

async fn run_queryable(instances: u32) -> Vec<zenoh::Result<Queryable<'static, ()>>> {
    // make session
    let session = zenoh::open(zenoh::config::default())
        .res_sync()
        .unwrap()
        .into_arc();
    
    // make names
    let mut names = Vec::new(); 
    for i in 0..instances {
        let name = format!("some/key/expr{}", i);
        names.push(name);
    }

    // make queryables
    let mut queryables = Vec::new(); 
    for name in &names {
        let queryable = session.declare_queryable(name)
                                                                .callback( |q| { async_std::task::spawn(echo(q));} ).res_async();
        queryables.push(queryable);
    }

    return futures::future::join_all(queryables).await;
}


fn run_check_zenoh_query(instances: u32) {
    print!("Starting queryables....");
    let queryables = async_std::task::block_on(run_queryable(instances));
    print!("...started");
    print!("Starting polling....");
    async_std::task::block_on(run_querying(instances));
}

//#[test]
fn check_zenoh_query() {
    run_check_zenoh_query(1);
}

//#[test]
fn check_zenoh_query_100() {
    run_check_zenoh_query(100);
}
